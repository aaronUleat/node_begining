## Scaning Node Modules

Veamos primero un ejemplo. Si un archivo /home/ryo/project/foo.js tiene un requerimiento de llamada ('bar'), Node.js
explora el sistema de archivos en busca de node_modules en el siguiente orden. Se devuelve el primer bar.js que se encuentra.

* /home/ryo/project/node_modules/bar.js
* /home/ryo/node_modules/bar.js
* /home/node_modules/bar.js
* /node_modules/bar.js

En otras palabras, Node.js busca  node_modules / bar.js  en la carpeta actual seguida de cada carpeta principal
hasta que llegue a la raíz del árbol del sistema de archivos para el archivo actual o 
hasta que se encuentre un bar.js. Un ejemplo simple de esto es
un módulo foo.js que carga un módulo node_modules / bar.js, como se muestra en el Listado 4-1 y en el Listado 4-2.

Listing 4-1. hello/foo.js

```
var bar = require('bar');
bar(); // hello node_modules!
```

Listing 4-2. hello/node_modules/bar.js

```
module.exports = function () {
console.log('hello node_modules!');
}
```
Como puede ver, nuestro módulo bar.js tiene exactamente el mismo aspecto que si estuviéramos usando módulos basados ​​en archivos.
Y eso es intencional. La única diferencia entre los módulos basados ​​en archivos y los node_modules es la forma en que el archivo
El sistema se escanea para cargar el archivo JavaScript. Todo otro comportamiento es el mismo.

