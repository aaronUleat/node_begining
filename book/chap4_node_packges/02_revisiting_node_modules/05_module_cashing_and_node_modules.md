## Module Caching and node_modules

Es posible que recuerde de nuestra discusión en el Capítulo 3 que requiere 
que almacene en caché el resultado de una llamada requerida después de la primera vez.
La razón es el aumento de rendimiento que se obtiene al no 
tener que cargar JavaScript y ejecutarlo nuevamente desde el sistema de archivos
y otra vez. Dijimos que require devuelve el mismo objeto cada vez que la ruta se resuelve en el mismo archivo.

Como ya hemos mostrado, los módulos de nodo son solo una 
forma diferente de escanear los módulos basados ​​en archivos. Por lo tanto,
siguen la misma regla de almacenamiento en caché del módulo. 
Si tiene dos carpetas donde el módulo A y el módulo B requieren módulo foo
es decir, requieren ('foo'), que está presente en alguna carpeta principal 
como se muestra en el Listado 4-8, obtienen el mismo objeto
(tal como se exporta desde node_modules / foo / index.js en el ejemplo dado).

Listing 4-8. Both Modules Get the Same foo Module

```
projectroot
    |-- node_modules/foo/index.js
    |-- moduleA/a.js
    |-- moduleB/b.js
```

Sin embargo, considere la organización del código como se muestra 
en el Listado 4-9. Aquí el módulo B requiere ('foo') llamada se resolverá
to moduleB / node_modules / foo / index.js, mientras 
que moduleA require call se resolverá en node_modules / foo / index.js
Y por eso no consiguen el mismo objeto.

Listing 4-9. Module A and B Get Different foo Module

```
projectroot
    |-- node_modules/foo/index.js
    |-- moduleA/a.js
    |-- moduleB
        |-- node_modules/foo/index.js
        |-- b.js
```
Esto es bueno porque ya hemos visto que le impide entrar en un problema de dependencia. Pero esto
desconexión es algo de lo que deberías ser consciente.