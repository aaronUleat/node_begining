## Folder_base module

Antes de discutir todas las ventajas del mecanismo de node_modules, necesitamos aprender un último truco de organización de código
soportado por la función Node.js requiere. No es raro tener varios archivos trabajando hacia un objetivo singular.
Tiene sentido organizar estos archivos en un único módulo que se puede cargar con una sola llamada de require. Nosotros discutimos
organizar dichos archivos en una sola carpeta y tener un index.js para representar la carpeta en el Capítulo 3.

Este es un escenario tan común que Node.js tiene soporte explícito para este mecanismo. Es decir, si un camino a la
el módulo se resuelve en una carpeta (en lugar de un archivo), Node.js buscará un archivo index.js en esa carpeta y lo devolverá como
archivo de módulo. Esto se demuestra en un ejemplo simple (chapter4 / folderbased / indexbased1) donde exportamos dos
Los módulos bar1.js y bar2.js usan un index.js y cargan la barra de módulos (e implícitamente bar / index.js) en un módulo
foo, como se muestra en el Listado 4-3 (ejecute node folderbased / indexbased1 / foo.js).

Listing 4-3. Implicit Loading of index.js from a Folder (Code: folderbased/indexbased1)

```
// bar/bar1.js
module.exports = function () {
    console.log('bar1 was called');
}
// bar/bar2.js
module.exports = function () {
    console.log('bar2 was called');
}

// bar/index.js
exports.bar1 = require('./bar1');
exports.bar2 = require('./bar2');
// foo.js
var bar = require('./bar');
bar.bar1();
bar.bar2();
```

Como dijimos anteriormente, la única diferencia entre los módulos basados ​​en archivos y los módulos de nodo es la forma en que
el sistema de archivos es escaneado Entonces, para una llamada como require ('./ bar'), el mismo código para node_modules sería un simple
mueva la carpeta de la barra a la carpeta node_modules / bar y cambie la llamada requerida de require ('./ bar') a
requiere ('bar').

Este ejemplo está presente en la carpeta chapter4 / folderbased / indexbased2 (ejecute el nodo folderbased /
indexbased2 / foo.js). Dado que la llamada ahora se resuelve en la carpeta node_modules / bar, Node.js busca node_modules / bar /
index.js y desde que se encuentra, eso es lo que se devuelve para require ('bar'). (Ver Listado 4-4.)

Listing 4-4. Implicit Loading of index.js from a node_modules/module Folder (Code: folderbased/indexbased2)
```
// node_modules/bar/bar1.js
module.exports = function () {
    console.log('bar1 was called');
}
// node_modules/bar/bar2.js
module.exports = function () {
    console.log('bar2 was called');
}

// node_modules/bar/index.js
exports.bar1 = require('./bar1');
exports.bar2 = require('./bar2');

// foo.js
var bar = require('bar'); // look for a node_modules module named bar
bar.bar1();
bar.bar2();
```

La semántica de llamada require es exactamente igual para los módulos de nodo que para los módulos principales (compare
requiere ('fs') requerir una llamada a la función ('bar'). Esto es intencional. Tienes la sensación de expandir el construido en
Funcionalidad Node.js al usar node_modules.

Usar una organización de código basada en carpetas al trabajar con node_modules es una estrategia común y lo que
debe hacer siempre que sea posible. En otras palabras, absténgase de crear archivos JavaScript de nivel superior en los node_modules
carpeta si todo lo que quieres es un solo archivo. Luego, en lugar de node_modules / bar.js, use un archivo node_modules / bar / index.js.




